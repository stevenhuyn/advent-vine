
use #root::data::Array;

pub fn main(&io: &IO) {
  // (HasRoll, Marked, x, y)
  let grid = Array::empty[Array[(Bool, Bool, I32, I32)]];
  let y = +0;
  while io.read_line() is Some(line) {
    let x = +0;
    let row = line.iter().map(fn* (c: Char) {
      let result = if c == '@' {
        (true, false, x, y)
      } else {
        (false, true, x, y)
      };

      x += +1
      return result;
    }).collect[List, _, _]() as Array;
    grid.push_back(row);
    y += +1
  }

  let height = grid.len();
  let width = grid.get(0).assume().len();
  let accessible = 0;

  let removed = false;
  for i in 0..1000 {
    grid = grid.map_unordered(fn* (row: Array[(Bool, Bool, I32, I32)]) {
      return row.map_unordered(fn* (cell: (Bool, Bool, I32, I32)) {
        let (roll, _, x, y) = cell;
        if !roll {
          return cell;
        }

        let neighs = 0;
        for (dx, dy) in [
          (-1, -1),
          (-1, +0),
          (-1, +1),
          (+0, -1),
          (+0, +1),
          (+1, -1),
          (+1, +0),
          (+1, +1),
        ].iter() {
          let nx = (dx + x) as N32;
          let ny = (dy + y) as N32;
          if nx >= 0 and nx <= width - 1 and ny >= 0 and ny <= height - 1 {
            if grid.get(ny).assume().get(nx).assume().0 {
              neighs += 1;
            }
          }
        }

        if neighs < 4 {
          accessible += 1;
          removed = true;
          return (roll, true, x, y);
        }

        return cell;
      });
    });

    grid = grid.map_unordered(fn* (row: Array[(Bool, Bool, I32, I32)]) {
      return row.map_unordered(fn* (cell: (Bool, Bool, I32, I32)) {
        let (_, marked, x, y) = cell;
        if marked {
          return (false, marked, x, y);
        }

        return cell;
      });
    });

    if !removed {
      break;
    }

    if i == 0 {
      io.println("p1: {accessible}");
    }
  }

  io.println("p2: {accessible}");
}