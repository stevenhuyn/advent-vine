
use #root::data::Array;

pub fn main(&io: &IO) {
  // (HasRoll, Marked, x, y)
  let grid = List::empty[(Bool, Bool, N32, N32)];
  let y = 0;
  let x = 0;
  while io.read_line() is Some(line) {
    x = 0;

    for c in line.iter() {
      let result = if c == '@' {
        (true, false, x, y)
      } else {
        (false, true, x, y)
      };

      x += 1
      grid.push_back(result);
    }

    y += 1
  }

  let height = x;
  let width = y;

  let accessible = 0;
  let grid = grid as Array;
  let removed = false;
  for i in 0..1000 {
    removed = false;
    let marked = List::empty[(N32, N32)]
    for y in 0..height {
      for x in 0..width {
        let (roll, _, _, _) = grid.get(index(x, y, width)).assume();

        if !roll {
          continue
        }

        let neighs = 0;
        for (dx, dy) in [(-1, -1),(-1, +0),(-1, +1),(+0, -1),(+0, +1),(+1, -1),(+1, +0),(+1, +1),
        ].iter() {
          let nx = (dx + x as I32)
          let ny = (dy + y as I32);

          if nx >= +0 and nx <= width as I32 - +1 and ny >= +0 and ny <= height as I32 - +1 {
            if grid.get(index(nx as N32, ny as N32, width)).assume().0 {
              neighs += 1;
            }
          }
        }

        if neighs < 4 {
          marked.push_back((x, y))
        }
      }
    }

    for (x, y) in marked.iter() {
      grid.at(index(x, y, width)).assume().* = (false, true, x, y)
      accessible += 1;
      removed = true;
    }

    if !removed {
      break;
    }

    if i == 0 {
      io.println("p1: {accessible}");
    }
  }

  io.println("p2: {accessible}");
}

pub fn index(x: N32, y: N32, width: N32) -> N32 {
  return y * width + x;
}